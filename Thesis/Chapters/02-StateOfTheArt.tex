% !TEX root = ../Thesis.tex

\chapter{Il linguaggio FACPL e il software OpenNebula}
\label{cap:capitolo2}
L'obiettivo di questo capitolo è introdurre i concetti di base del linguaggio FACPL e del software OpenNebula, necessari per comprendere il lavoro svolto in questa tesi. In particolare, sarà discusso il funzionamento del linguaggio FACPL, le sue caratteristiche principali e le motivazioni che hanno portato al suo utilizzo. Successivamente verrà presentato il software OpenNebula, sarà descritta la sua architettura e saranno evidenziate funzionalità ritrovabili all'interno dei progetti descritti nei capitoli successivi, in modo da comprendere come si può adattare ad un sistema di gestione delle policy basato su FACPL.\medbreak
\section{Il linguaggio FACPL}
Il linguaggio FACPL\footnote{\cite{FAPCLTesi}} è stato ideato nel 2012 come risposta alla necessità di sistemi di controllo degli accessi più flessibili e adattabili di quelli già esistenti. In particolar modo il linguaggio viene spesso paragonato con XACML, questo perchè è attualmente il inguaggio più largamente utilizzato per il controllo degli accessi ma anche perchè FACPL è stato sviluppato proprio come risposta ad alcune evidenti problematiche di XACML. Il problema principale che FACPL punta a risolvere è la mancanza di una semantica definita formalmente, il che rende difficile ideare delle tecniche di analisi.\medbreak
\section{Componenti del sistema FACPL}
\label{sec:componentiFACPL}
FACPL trae larga ispirazione da XACML, in particolar modo per la struttura base delle policy e anche per una parte della terminologia. il linguaggio presenta due tipoligie di policy, le \emph{authorisation properties} che permettono di valutare una policy rispetto ad una richiesta e le \emph{structural properties} che permettono di svolgere una valutazione su un insieme di valutazioni svolte su una o più policy.
Come si può vedere nell'immagine \ref{fig:facplEvaluationProcess}\footnote{\cite{facpl}} Il sistema FACPL è composto da alcuni componenti principali:
\begin{figure}[h]
    \centering
    \includesvg[width=\textwidth]{facplEvaluationProcess.svg}
    \caption{Processo di valuatione di FACPL}
  \end{figure}
\label{fig:facplEvaluationProcess}
\begin{itemize}
    \item \emph{PEP:} Policy Enforcement Point, è il componente che si occupa di verificare la compatibilità della richiesta con le policy. Nessuna operazione di valutazione è svolta in questo componente, infatti come si può vedere dall'immagine \ref{fig:facplEvaluationProcess} la richiesta viene inviata al \emph{PDP} per essere valutata e questo restituisce il risultato da usare nel \emph{PEP}. Per l'esecuzione delle obbligazioni si affida agli \emph{Obligation services}. In FACPL il \emph{PEP} è però anche portato a svolgere una scelta in situazioni in cui il \emph{PDP} non è in grado di fornire una risposta.
    \item \emph{PDP:} Policy Decision Point, è il componente che riceve le richieste dal \emph{PEP} e le valuta in base alle policy presenti nel \emph{PR}. Il risultato della valutazione è restutuito al \emph{PEP}.
    \item \emph{PR:} Policy Repository, è il componente che si occupa di memorizzare le policy e di fornirle al Policy Decision Point.
    \item \emph{Context Handler:} come si può vedere si trova in mezzo nel percorso fra \emph{PEP} e \emph{PDP}, e sia le richieste che risposte passano sempre da questo componente. Il suo compito è quello di fornire il contesto necessario per valutare le richieste, infatti come si può vedere è strettamente legato ad \emph{Environment} a cui chiede i valori degli attributi necessari per la valutazione.
    \item \emph{Environment:} questo componente non è definito in modo specifico, deve infatti essere implementato in base al sistema in uso ed ha come compito quello di fornire valori attuali di specifici attributi.
    \item \emph{Requester:} è il componente che invia le effettive richieste al \emph{PEP}
    \item \emph{Obligation services}: è il componente attua le obbligazioni e verifica l'esito dell'esecuzione. La decisione del \emph{PEP} dipende dal risultato dell'esecuzione delle obbligazioni, se queste non sono state eseguite con successo la richiesta non da esito positivo.
\end{itemize}
\section{Modalità di utilizzo di FACPL}
FACPL viene distribuito come una repository p2 di Eclipse, questo permette di installarlo direttamente tramite la UI di Eclipse in modo molto facile. FACPL richiede l'utilizzo di Java 8 anche se non risulterebbe difficile integrarlo in progetti che utilizzao versione di Java successive con qualche accorgimento.\medbreak
Il metodo principale per sviluppare un progetto FACPL è crearlo direttamente con l'interfaccia di Eclipse, in questo modo viene creato un progetto con tutte le dipendenze necessarie. Si nota come FACPL sia pensato per essere usato tramite la sua sintassi di alto livello e non tramite Java direttamente, di conseguenza è di solito richiesto al programmatore di scrivere codice Java solo per tre componenti del sistema, il \emph{Context Handler}, l'\emph{Environment} e gli \emph{Obligation services}.\medbreak
Il \emph{Context Handler} deve soltanto essere leggermente modificato per adattarsi ad interagire con l'\emph{Environment}, che invece è la parte fondamentale da scrivere. L'\emph{Environment} può essere scritto come si preferisce, basta che sia in grado di comunicare con il \emph{Context Handler} quindi può potenzialmente essere scritto in qualsiasi linguaggio di programmazione. Questa logica rende FACPL facilmente adattabile ad un grande numero di casi concreti. Per quanto riguarda gli \emph{Obligation services} occorre integrare quelle che sono chiamate \emph{PEPAction}, ovvero i comandi che vengono effettivamente lanciati come obbligazioni, in questo caso il contratto da rispettare è che siano tutte classi che implementano l'interfaccia \texttt{IPepAction} e quindi che presentino il metodo \texttt{evaluate} con cui vengono chiamate dal \emph{PEP}.\medbreak
Per la scrittura di file \texttt{.fpl} in sintassi FACPL è fornito un editor apposito realizzato con Xtext\cite{eclipseXtext} ed accessbile comodamente da Eclipse automaticamente dopo l'installazione della repository p2. L'editor presenta alcune funzioni tipiche degli IDE come l'identificazione di \emph{warning} e \emph{errors} che permettono di capire se si sono svolti degli errori di sintassi, oltre che l'highlighting della sintassi. Vengono messi inoltre a disposizione dei generatori automatici di codice Java, XACML e SMT-LIB a partire da un file \texttt{.fpl}; questi generatori sono accessibili dalla UI di Eclipse. Nella repository del progetto su github\footnote{\url{https://github.com/andreamargheri/FACPL}} sono inoltre presenti diversi codici di esempio.\medbreak

\section{Il software OpenNebula}
OpenNebula\cite{opennebula} è definita come una piattaforma open-source potente, ma semplice da utilizzare, che si può usare per costruire e gestire infstratture Cloud. L'idea dietro OpenNebula è quella di fornire una struttura per la gestione unificata per le infrastrutture IT e le applicazioni, evitando di dover utilizzare strumenti closed-source e proprietari per cui di solito è richiesto un alto costo di acquisto e gestione.\medbreak
OpenNebula permette di gestire diversi hypervisor come KVM, VMware, Xen e LXD, consentendo quindi di creare diversi tipi di virtual machine e container e permette anche di scegliere diverse modalità per la gestione dello storage.
\section{Architettura di OpenNebula}
OpenNebula è una piattaforma che si compone di diversi componenti, ognuno dei quali svolge un ruolo ben preciso all'interno del sistema. I componenti sono presentanti tutti all'interno della documentazione ufficiale\footnote{\url{https://docs.opennebula.io/6.8/overview/opennebula\_concepts/opennebula\_overview.html\#id1}}, in questo capitolo verranno presentati solo quelli fondamentali per capire il funzionamento di OpenNebula in un caso di studio come quello descritto in questa tesi:
\begin{itemize}
    \item \emph{OpenNebula Daemon:} Questo è il servizio centrale della piattaforma cloud. Gestisce i nodi, le reti, lo storage, i gruppi e gli utenti. Questo servizio è responsabile di coordinare tutte le operazioni e risponde alle chiamate XML-RPC fatte con le apposite API. Solitamente questo servizio è eseguito su un nodo che può anche essere usato come host.
    \item \emph{Host:} Ogni host rappresenta un server che è gestito da OpenNebula e può essere utilizzato per eseguire delle virtual machine. Ogni host deve installare tutte le dipendenze necessarie e deve successivamente essere registrato in OpenNebula. Ogni host può presentare un solo hypervisor, anche se ci sono modi per cercare di aggirare questa limitazione.
    \item  \emph{User:} OpenNebula permette di gestire utenti e gruppi in modo del tutto separato dal modo in cui sono gestiti in Unix. Ogni utente ha un'\emph{ID} univoco e può appartenere ad uno o più gruppi. Di default viene creato l'utente \texttt{oneadmin} che ha tutti i permessi e può creare nuovi utenti e gruppi. Gli utenti del gruppo \texttt{oneadmin} hanno gli stessi permessi dell'utente \texttt{oneadmin} mentre gli utenti creati e inseriti in altri gruppi possono avere diversi permessi.
    \item \emph{Virtual Machine Template:} In OpenNebula le virtual machine sono definite a partire da un template, che contiene tutte le informazioni necessarie per crearle, come capacità di memoria, CPU e dischi da utilizzare. I template possono essere definiti a partire da zero, usando l'appropriata sintassi ma sono disponibili anche presso degli store online e possono essere modificati a piacimento. Conoscere il template con cui è stata creata una virtual machine fornisce moltissime informazioni su come è configurata. La UI e la CLI forniscono strumenti per verificare la correttezza di un template che si intende salvare.
    \item \emph{Sunstone:} OpenNebula fornisce diverse interfacce per la gestione delle risorse, quella più user-friendly è sicuramente Sunstone ovvero una Web-ui che è utilizzabile sia da utenti che da supervisori. Quando viene fatta l'installazione di OpenNebula, Sunstone è installata automaticamente ma è gestita da un demone separato, di conseguenza può essere spenta se non utilizzata. L'alternativa a Sunstone è utilizzare la CLI, che per alcuni comandi rimane comunque più veloce.
\end{itemize}
\section{XML-RPC e OpenNebula}
Il protocollo XML-RPC\cite{xmlrpc} è un protocollo che permette di eseguire chiamate a procedure remote (\emph{Remote Procedure Call}) attraverso la rete. Come indicato dal nome utilizza lo standard XML per la codifica della richiesta e si basa su HTTP per il trasporto dei dati.\medbreak
L'idea dietro questo protocollo è di rimanere il più semplice possibile permettendo però anche di gestire strutture dati complesse. Il potocollo è stato sviluppato da Dave Winer e Microsoft nel 1998 e da allora è stato largamente utilizzato ma anche mantenuto e migliorato.
A partire dal 2019 il protocollo ha una nuova implementazione in JavaScript che permette anche l'utilizzo di sintassi Json oltre che XML.\medbreak
OpenNebula utilizza XML-RPC per mettere in comunicazione i componenti del sitema, come si può vedere direttamente nella documentazione ufficiale\footnote{\url{https://docs.opennebula.io/6.8/integration_and_development/system_interfaces/api.html}}