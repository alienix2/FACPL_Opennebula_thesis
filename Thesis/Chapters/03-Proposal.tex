% !TEX root = ../Thesis.tex

\chapter{Integrazione di OpenNebula con FACPL}
\label{cap:proposal}
Come già discusso nel capitolo \ref{cap:stateOfArt}, grazie al modo in cui FACPL\cite{facpl} è costruito risulta molto facile andare a fornire un'implementazione concreta dei PEP (\emph{Policy Enforcement Point}) e PDP (\emph{Policy Decision Point}) avendo conoscenza  di quali sono le esigenze a cui devono rispondere.\\
Per validare ulteriormente questo punto abbiamo deciso di utilizzare FACPL in una situazione in cui fosse necessario interfacciarsi con un software già esistente così da mostrare le effettive potenzialità e semplicità di implementazione della libreria.
Il caso concreto che abbiamo deciso di considerare deriva da un possibile sviluppo futuro già proposto all'interno di \cite{10.1007/978-3-319-08260-8_6}, ovvero un'integrazione con un "sistema di IaaS open-source sul cloud" come OpenNebula\cite{opennebula}, software che è stato già presentato all'interno del capitolo \ref{cap:stateOfArt}.

\section{Idea di base}
Per iniziare abbiamo considerato due esempi di gestione delle risorse disponibili aderenti alla realtà e una spiegazione abbastanza dettagliata del loro funzionamento, presenti all'interno di \cite{10.1007/978-3-319-08260-8_6}.
Abbiamo inoltre potuto osservare due primi tentativi di implementazione descritti sempre all'interno di \cite{10.1007/978-3-319-08260-8_6}:
\begin{itemize} 
    \item il primo sviluppato basandosi su una completa astrazione, ovvero dei files che simulano un sistema con diverse virtual machine, che è presente anche in \cite{facpl-github} fra gli esempi nella cartella "\emph{EXAMPLES}"
    \item il secondo basato su uno XEN Hypervisor, che però non è presente fra gli esempi forniti assieme alla libreria e di cui non vengono esplicitati i dettagli di implementazione.
\end{itemize}
Con questa conoscenza l'obiettivo iniziale è stato quello di riuscire ad interagire con un reale sistema su cui è installato un cloud manager per fare si che questo eseguisse i comandi necessari per eseguire le PEP action da noi richieste e ci esponesse tutte le informazioni necessarie al PDP per valutare le richieste.
Nel concreto era quindi necessario pensare a due parti distinte:
\begin{itemize}
    \item una che svolgesse operazioni sulle singole virtual machine (avviarle, inserire nell'host corretto, fermarne l'esecuzione).
    \item una che recuperasse le informazioni generali sugli host e sul sistema tutto.
\end{itemize}
Il cloud manager che abbiamo deciso di utilizzare è stato OpenNebula per i motivi presentati nel capitolo \ref{cap:stateOfArt}

\section{OpenNebula API}
Il primo approccio che avevamo pensato di percorrere era quello di utilizzare il codice Java per invocare dei comandi da shell che fossero in grando di interagire con OpenNebula. Questo approccio sembrava il più immediato anche dato lo studio preliminare di OpenNebula che avevamo svolto che era stato soprattutto attraverso la shell (oltre che la web ui).\\
Per utilizzare i comandi da shell che permettono di interagire con OpenNebula occorre aver effettuato l'autenticazione come utente OpenNebula\footnote{\url{https://docs.opennebula.io/6.8/management_and_operations/users_groups_management/manage_users.html}}.
Questa soluzione aveva il principale vantaggio di poter fornire un'interfaccia generica che permettava in un futuro di far interagire con sforzo minimo FACPL anche con comandi di natura completamente diversa, tuttavia presentava anche diverse problematiche come la forte dipendenza dalla versione di OpenNebula installata nel sistema e una grande inefficienza nello svolgimento di alcune operazioni.\\

La strada su cui ci siamo orientati è stata quindi quella di utilizzare le API di OpenNebula per Java\footnote{\url{https://docs.opennebula.io/6.8/integration_and_development/system_interfaces/java.html}} in quanto queste semplificavano l'ottenimento di alcune informazioni. Come è possibile leggere dal sito di OpenNebula stesso, queste API sono a loro volta un wrapper dei metodi XML-RPC\footnote{\url{https://docs.opennebula.io/6.8/integration_and_development/system_interfaces/api.html\#api}}\\

Le API utilizzate sono quelle della versione 5.12.0\footnote{\url{https://downloads.opennebula.io/packages/opennebula-5.12.0/}} dato che dopo la major version 5 sono compilate con la versione di Java 11 (al contrario di quato riportato sul sito stesso) e di conseguenza non erano compatibili con la versione di Java 8 con cui è stato sviluppato FACPL.
I principali attori che sono stati utilizzati dalle API\footnote{\url{https://docs.opennebula.io/doc/6.4/oca/java/org/opennebula/client/package-summary.html}} sono stati:
\begin{itemize}
    \item \emph{Client}: è la classe principale che gestisce la connesione fra il core di OpenNebula e le chiamate XML-RPC, quasi tutti gli altri oggetti delle API richiedono di passare un oggetto di questo tipo per poter essere istanziati. Questo oggetto può essere istanziato passando uno \emph{username} e una \emph{password} al costruttore, ma presenta anche un costruttore che non richiede parametri e permette di derivare \emph{username} \emph{password} dall'utente corrente.
    \item \emph{ClientConfigurationException}: è la classe che rappresenta l'eccezione che viene lanciata se si tenta di istanziare un \emph{Client} con delle impostazioni di autorizzazione sbagliate, in particolare se \emph{username} \emph{password} sono errate oppure se si tenta di usare il costruttore vuoto lanciando il programma da un utente che non è uno user di OpenNebula.
    \item \emph{OneResponse}: è la classe che incapsula le risposta XML-RPC di OpenNebula, viene istanziata con un \emph{boolean} e una \emph{String} che rappresentano rispettivamente l'esito della richiesta (positivo o negativo) e un eventuale messaggio che lo descrive. Quasi tutte le azioni eseguibili sui \emph{PoolElement} ritornano un oggetto di questo tipo.
    \item \emph{Pool}: è la classe che rappresenta un insieme di \emph{PoolElement} e fornisce la possibilità di scorrere gli stessi ed eseguire in modo agevolato alcune operazioni
    \item \emph{PoolElement}: è la superclasse della maggior parte delle classi che rappresentano gli elementi di OpenNebula, quelli più interessati nel progetto sono stati
    \begin{itemize}
        \item \emph{VirtualMachine}
        \item \emph{Host}
        \item \emph{Template}
    \end{itemize}
\end{itemize}

\section{Logging}
Prima ancora di pensare ai comandi da eseguire sulle virtual machine si è reso necessario pensare ad una modalità di logging. Dato l'ambito di applicazione si è reso fondamentale pensare ad una scrittura di logs su file di modo da rendere gli stessi facilmente accessibili in futuro, anche a distanza di tempo.\\
All'interno del progetto è quindi fornita una classe \texttt{FileLoggerFactory} che utilizza il design pattern \emph{Static Factory Methods} \cite{effectiveJava} e permette di creare dei file di log, di modo da evitare la necessità di interagire coi file in ogni classe che intende eseguire il log di informazioni oltre che gestire in modo consono gli handler dei files evitando duplicati. Questa classe permette di creare dei \texttt{Logger} con un'implementazione di \texttt{Level} e \texttt{Formatter} di default oppure di specificare questi parametri in input.\\
\begin{lstlisting}[language=Java, caption=Metodo make di FileLoggerFactory, label=code:FileLoggerFactoryMake]
public static Logger make(String fileName, Formatter formatter, Level level) {
    Throwable t = new Throwable();
    StackTraceElement directCaller = t.getStackTrace()[1];
    String loggerName = directCaller.getClassName() + "-" + fileName;

    Logger logger = Logger.getLogger(loggerName);

    @\mytikzmark{hl1Start}@if (!isFileHandlerAttached(logger, fileName)) {@\mytikzmark{hl1End}@
        try {
            FileHandler fileHandler = createFileHandler(fileName, formatter, level);
            logger.addHandler(fileHandler);
            logger.setUseParentHandlers(false);
        } catch (IOException e) {
            throw new RuntimeException("Failed to initialize logger handler.", e);
        }
        @\mytikzmark{hl2Start}@}@\mytikzmark{hl2End}@

    return logger;
}
    \end{lstlisting}
    \begin{tikzpicture}[remember picture, overlay]
        \highlight{hl1Start}{hl1End}
        \highlight{hl2Start}{hl2End}
    \end{tikzpicture}
Nonostante la presenza di questa classe, tutte le classi all'interno del progetto hanno i logger passati tramite dependency injection e forniscono un'implementazione di default che esegue logging nello stsandard output (solitamente la console). L'unica classe che fa eccezione in questo è proprio \texttt{ContextStub\_Default} che è il primo punto di ingresso della dipendenza.\\
L'idea è che nel caso in cui si preferisca eseguire logging in modo diverso si possa definire un logger diverso al posto dell'implementazione proposta. Per farlo occorre semplicemente modificare una riga all'interno del costruttore di \texttt{ContextStub\_Default}:
\begin{lstlisting}[language=Java, caption=Costruttore ContextStub\_Default, label=code:CostContextStub]
public static ContextStub_Default getInstance() {
    if (instance == null) {
        try {
            ContextStub_Default.oneClient = new Client();
            @\mytikzmark{hl1Start}@Logger logger =@\mytikzmark{hl1End}@ @\mytikzmark{hl2Start}@FileLoggerFactory.make("logs/virtualMachines.log");@\mytikzmark{hl2End}@
            initializeStub(oneClient, logger);
            instance = new ContextStub_Default();
        } catch (ClientConfigurationException e) {
            throw new RuntimeException("Failed to initialize Client: " + e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException("Unexpected error during ContextStub_Default initialization: " + e.getMessage(), e);
        }
    }
    return instance;
}
\end{lstlisting}
\begin{tikzpicture}[remember picture, overlay]
    \highlight{hl1Start}{hl1End}
    \highlight{hl2Start}{hl2End}
\end{tikzpicture}

\section{Gestione delle virtual machine}
Per gestire le virtual machine l'approccio iniziale è stato quello di fornire un'interfaccia che permettesse in un futuro di poter interagire con le stesse anche in modo.\\
E' stata creata una classe wrapper chiamata \texttt{VMDescriptor} che contiene le informazioni sulle virtual machine utili per il nostro progetto, questa classe serve per creare una prima astrazione dalle API utilizzate, in effetti questa stessa classe permetterebbe, ad esempio, di fornire un'implementazione come quella precedentemente pensata basata sui comandi da shell.
L'interfaccia \texttt{VirtualMachineService} presenta due metodi che servono per lavorare all'effettivo con i \texttt{VMDescriptor}.
\begin{lstlisting}[language=Java, caption=VirtualMachineService, label=code:VirtualMachineService]
public interface VirtualMachineService {
    List<VMDescriptor> getVirtualMachinesInfo();
    List<VMDescriptor> getRunningVirtualMachineInfo();
}
\end{lstlisting}
La scelta di avere due metodi separati per restituire tutte le macchine virtuali oppure solo quelle attualmente in esecuzione deriva dal fatto che in effetti spesso queste due liste vorranno essere utilizzate in modo diverso. Di solito le VirtualMachine presenti nel sistema sono molte più di quelle effettivamente in esecuzione e questo avrebbe portato una buona parte delle classi che volevano utilizzare un'implementazione di questa interfaccia a dover sempre inserire un controllo sullo stato delle VM.
Nel codice da me scritto viene utilizzata la sua implementazione concreta \texttt{VirtualMachineService} che, interfacciandosi con le API di OpenNebula già descritte, riesce ad ottenere tutte le informazioni richieste sulle VM e a popolare le liste.

\section{How did I discover a novel type of heated water}

Explain in detail what are the steps to heat the water in a novel way.

\section{How my heated water differs from the previous ones}

Describe why and how your findings are different from the past versions.

Here you might want to add code (see for example Listing~\ref{code:example}), or tables (see Table~\ref{tab:example}).

Note that figures, listings, tables, and so on, should never be placed `manually'. Let LaTeX decide where to put them - you'll avoid headaches (and bad layouts). Furthermore, each of them must be referred to at least once in the body of the thesis.

\begin{minted}{java}
import java.awt.Rectangle;

public class ObjectVarsAsParameters
{	
    public static void main(String[] args)
    {	go();
    }
    
    public static void go()
    {	
        Rectangle r1 = new Rectangle(0,0,5,5);
        System.out.println("In method go. r1 " + r1 + "\n");
        // could have been 
        //System.out.prinltn("r1" + r1.toString());
        r1.setSize(10, 15);
        System.out.println("In method go. r1 " + r1 + "\n");
        alterPointee(r1);
        System.out.println("In method go. r1 " + r1 + "\n");
        
        alterPointer(r1);
        System.out.println("In method go. r1 " + r1 + "\n");
    }
    
    public static void alterPointee(Rectangle r)
    {	
        System.out.println("In method alterPointee. r " + r + "\n");
        r.setSize(20, 30);
        System.out.println("In method alterPointee. r " + r + "\n");
    }
    
    public static void alterPointer(Rectangle r)
    {	
        System.out.println("In method alterPointer. r " + r + "\n");
        r = new Rectangle(5, 10, 30, 35);
        System.out.println("In method alterPointer. r " + r + "\n");
    }
}
\end{minted}

\begin{lstlisting}[language=Java, caption=Java example, float, label=code:example]
import java.awt.Rectangle;

public class ObjectVarsAsParameters
{	public static void main(String[] args)
    {	go();
    }
    
    public static void go()
    {	Rectangle r1 = new Rectangle(0,0,5,5);
        System.out.println("In method go. r1 " + r1 + "\n");
        // could have been 
        //System.out.prinltn("r1" + r1.toString());
        r1.setSize(10, 15);
        System.out.println("In method go. r1 " + r1 + "\n");
        alterPointee(r1);
        System.out.println("In method go. r1 " + r1 + "\n");
        
        alterPointer(r1);
        System.out.println("In method go. r1 " + r1 + "\n");
    }
    
    public static void alterPointee(Rectangle r)
    {	System.out.println("In method alterPointee. r " + r + "\n");
        r.setSize(20, 30);
        System.out.println("In method alterPointee. r " + r + "\n");
    }
    
    public static void alterPointer(Rectangle r)
    {	System.out.println("In method alterPointer. r " + r + "\n");
        r = new Rectangle(5, 10, 30, 35);
        System.out.println("In method alterPointer. r " + r + "\n");
    }
}
\end{lstlisting}

\begin{table}[tbp]
\centering
\caption{Example table}
\label{tab:example}
\begin{tabular}{@{}lll@{}}
\toprule
Country       & Country code & ISO codes \\ \midrule
Canada        & 1            & CA / CAN  \\
Italy         & 39           & IT / ITA  \\
Spain         & 34           & ES / ESP  \\
United States & 1            & US / USA  \\ \bottomrule
\end{tabular}
\end{table}

